/**
 * Author NoteJava.java - GrayFox | Ilya Lisin
 * Contact: Skype: foxygameskype | Telegram: +7(925)316-65-82 | vk: https://vk.com/exsperto1
 * GitHub: https://github.com/FoxITeam and https://github.com/GrayFoxIT
 * encoding: UTF-8, Comments, remarks in Russian.
 * Специальный класс для заметок для всех моих проектов!!
 */

public class NoteJava {
    public static void main(String[] args) {
        keyJava();
        OOPJava();
        definitionJava();
        noteJava();
        StringOp();
    }

    /**
     * todo | Литература, которую важно почитать:
     * todo | Брюс Эккель «Философия Java» (4-е полное издание) - https://lyapidov.ru/bruce-eckel-thinking-in-java-4th-edition/
     * todo | Структуры данных и алгоритмы Java - http://padabum.com/d.php?id=109037
     * todo | Важные заметки, которые очень пригодятся на следующих занятиях.
     */

    public static void keyJava() {
        System.out.println("Комбинации клавиш <start> ");
        /**
         * todo | fori - сокращение цикла for обычная, itar - сокрашения цикла for с массивом, iter.
         * todo | Примечание: fori sout psvm itar и подобные сокращения работают только в методах.
         * todo | psvm - public static void Main
         * todo | sout - System.out.println
         *
         * todo | Ctrl + shift + v - Буфер обмена запоминает 4 последних сохранения, можно выбрать и вставить то, что нам нужно.
         * todo | shift + ctrl + UP - строку поднять вниз, down опустить ниже.
         * todo | ctrl + F2 - остановить проект.
         * todo | CTRL + / - комментирования выделенных строк в коде.
         * todo | todo | Shift + F6 - переименования название методов/переменных.
         * todo | Alt+ctrl+L - форматирование текста и кода в IDEA, удобная вещь.
         * todo | Shift + F10 - запустить проект.
         * todo | ctrl + Alt + M - Прежде выделяем область и комбинацию. Она может выделенный фрагмент кода экстрактить в отдельный элемент кода.
         * todo | Alt + Insert = Можно сгенерировать геттеры и сеттеры.
         * todo | Ctrl + Y - вырезать строчку кода.
         * todo | CTRL + F - поиск, CTRL + R - замена слова.
         * todo | alt + Enter (Наводим на if или switch и мы можем переконвертировать их) с if в switch или наоборот.
         * todo | CTRL + SHIFT + ENTER - поставить точку с запятой и перейти на следующую строку.
         * todo | CTRL + D - копировать ту строку, на которую мы нажали и оно вставит ее ниже.
         * todo | CTRL + X - вырезать CTRL + V - вставить.
         * todo | Зажимаем ALT и выделяем, выделять будет квадратом.
         * todo | Alt + Insert - Создать класс, пакеты, при фокусе на scr или на пакетах (выбрать пакет или папку и нажать комбинацию).
         * todo | ctrl + P - Вызвать конструктор метода и посмотреть из чего же можно сделать строку.
         * todo | А если нажать на метод и ctrl + B, то можно перейти на метод и посмотреть его поведение.
         */
        System.out.println("Комбинации клавиш </end> ");
    }

    public static void OOPJava() {
        System.out.println("ООП <start> ");
        /**
         * todo | ООП это парадигма, принцип программирования объектно ориентированный
         * todo | Простыми словами, парадигмой называют  набор правил, принципов и понятий которые были сформированы по отношению к чему то. Самым ярким примером парадигмы могут послужить религиозные взгляды на наш мир.
         * todo | Все программы на java они состоят из классов. Функции в джава называются методом.
         * todo | Класс является базовой единицей всех программ java, все java программы представляют
         * todo | собой набор классов, Каждый класс определяет уникальный тип объектов (новый тип данных) (синонем)
         * todo | Каждый класс содержит набор полей (переменных) и методов (функции). Если переменная относиться ко всему классу, то она называется полем класса.
         * todo | Название файла в котором содержиться класс, должно совпадать с его именем. (аксиома)
         * todo | Класс является чертежом (или шаблоном) для создания объектов. (Объект и класс не синонимы)
         * todo | Экземпляр класса - это объект созданный по данному классу.
         * todo | Что такое объект - объект это предмет, если класс это чертеж машины, данной модели, то данная модель машины тойота камри - это вполне себе автомобиль, который
         * todo | едет по улице, у него есть свой номер, он поехал - это объект - Собранный объект класса! Уже собран по чертежу!
         * todo | Каждый объект имеет состояние и поведение, то есть тойота камри, 5 летний тойота камри с двигателем 2 литра.
         * todo | У каждого этого тойота камри (у каждого объекта) в баки может быть разное кол-ва топлива, но при этом они все являются объектом 1 класса, хотя и разными объектами.
         * todo | Каждый объект имеет свой уникальный адрес в памяти, объект является экземпляром класса (new).
         * todo | Конструктор, это метод, который возвращает экземпляр класса, но как то настроенный.
         * todo | То есть если "Экземпляр класса - это объект созданный по данному классу"
         * todo | то Конструктор возвращает экземпляр класса.
         * todo | По умолчанию у каждого класса есть конструктор по умолчанию и можно создать экземпляр класса из другого класса.
         * todo | Конструктор по умолчанию не видно, но он есть под капотом джавы. Если нажать ALT+ INSERT, то IDEA нам предложит
         * todo | какую то быструю вставку и первой же строкой будет конструктор
         * todo | ALT + INSERT и мы выбрали конструктор.
         * todo | По сути это метод, по имени этого класса "Car()", заметте - перегрузка методов тут позволена, так как она
         * todo | заложена в самой джаве (эту инфу я взял с книги эккеля), без возвращаемых параметров(значения), ну то что в скобках бы передаем нужные параметры - их там нет,
         * todo | но на самом деле оно есть, он возвращает метод возвращающий тип данного метода (класса). Но его так никто не записывает, так как он уже создан по умолчанию и от него смысла нет.
         * todo | Но по умолчанию он будет до тех пор, пока вы не переопределите свой конструктор.
         * todo | И так, для чего нужны конструкторы? Конструкторы это специальные методы, которые нужны для инициализации (ну для создания объектов данного класса)
         * todo | инициализированны уже какими либо значениями.
         * todo | Конструктор нельзя сделать приватным, потому что он станет бесполезным тогда! Не, не то что нельзя!
         * todo | Можно, почему, можно применять уровни доступа к конструктору, но приватным делать бессмысленно. Это как приватными делать геттеры и сеттеры, от которых толку потом не будет.
         * todo | Еще раз повторю, если сделать private наш конструктор, его никто и никогда не вызовет.
         * todo | И теперь при вызове экземпляра класса, у нас конструктор будет выдавать стандартные значения из этого класса.
         * todo | это очень удобно, когда мы просто хотим вызвать не вызывая конструктор.
         * todo | Если пользователь хочет переназвать модель, указать свой год и перекрасить, пусть он это делает принудительно в своем коде.
         * todo | Теперь мы можем переопределить конструктор и передать в него какие то параметры
         * todo | Теперь можно вызвать конструктор, передав в него параметр модели принудительно.
         * todo | и так, чтобы обратиться с такого конструктора с параметрами к модели, нужно написать перед model - this.
         * todo | Еще раз, Видите что model серая? а почему, потому что мы обращаемся к параметру, а чтобы обратиться к
         * todo | полю класса (а поле класса это "Каждый класс содержит набор полей (переменных) и методов (функции), Если переменная относиться ко всему классу, то она называется полем класса.)"
         * todo | чтобы обратиться к полю класса из метода, при вот таком вот перекрытии, а это нормальная практика при подобном перекрытии,
         * todo | нужно использовать слово this. - то есть this.model
         * todo | Ключевое слово this говорит нам о том, что мы обращаемся к данному классу, в котором находимся.
         * todo | То есть this.moder это тоже самое, что Car.model, только в случае Car.model у нас не статический, по этому this.
         * todo | То есть получить ссылку на самого себя. Но еще this нужно раскрурить, по этому мы можем назвать в параметрах конструктора
         * todo | this.name - если параметр, который приходит в метод, имеет тоже самое имя, что и поля данного класса, то этот параметр перекрывает поле.
         * todo | его не видно внутри метода, чтобы получить доступ к полю класса, нужно обращаться к нему через this.имя
         * todo | Геттеры и сеттеры - это специальные методы, геттер - возвращает, сеттер - устанавливает. От англ туГет туСет.
         * todo | Alt + Insert - создает их.
         * todo | Геттеры и сеттеры ограничивают доступы к полу класса, через геттер можно обратиться, через сеттер установить.
         * todo | Геттеры и сеттеры нужны для огранизации бизнес логики, допустим мы хотим перекрасить машину, но Вам нужно
         * todo | узнать что цвет не прозрачный! И мы проверям тут, что if - если цвет прозрачный, устанавливать цвет не будем.
         * todo | Если цвет null - не устанавливать цвет так же.
         * todo | Уровни доступа: private, default(ничего не написать), protected, public.
         * todo | Уровень доступа private говорит нам о том, что метод и поля видны только внутри нашего класса (даже не будут видны в наследниках)
         * todo | Уровень доступа (стандартный - ничего не писать) - поля и методы видны в пределах пакета
         * todo | Уровень доступа protected видны только для наследников и в пределах пакета.
         * todo | Уровень доступа public видны всем
         * todo | Переменными называют по другому полями класса
         * todo | Наследование - класс, который объединяет что то общее, например от кошки и собаки мы объединили общие параметры (имя, цвет, возраст), чтобы не писать лишний код и класс
         * todo | назвали - животное. В классах Dog и Cat мы экстендим класс Animal, то есть наследуем возможности в класс Cat и класс Dog возможности Animal.
         * todo | Любой класс в Java наследуется от Object (объект)
         * todo | Наследоваться только можно от 1 класса (extends) - множественное наследоваие не предусмотренно.
         * todo | Абстракции нужны для того, чтобы заготовить методы, которые мы будем переопределять *
         * todo | Что такое интерфейсы - если Класс это чертеж дома, то интерфейс это чертеж офиса. Он устанавливает правила
         * todo | а еще делает переменные сразу константами! *
         * todo | Как происходит передача объектов в методы в качестве параметров? Передача примитивов в методы в качестве параметров происходит по значению, а объектов – по ссылке.
         * todo | ВСЕ ПАРАМЕТРЫ В JAVA ПЕРЕДАЮТСЯ ПО ЗНАЧЕНИЮ. Если параметр — ссылка на объект, то ЗНАЧЕНИЕМ является ЗНАЧЕНИЕ самой ссылки, а не значение разнообразных полей в объекте, коих может быть великое множество, как по количеству, так и по разнообразию типов.
         */
        System.out.println("ООП </end> ");

    }

    public static void definitionJava() {
        System.out.println("Определения <start> ");
        /**
         * todo | Что такое переменная - по факту это ссылка в адрес памяти и что по этому адресу лежит
         * todo | определяется типом нашей переменной. Типы переменных бывают 2 видов - это
         * todo | примитивные и ссылочные, их всего восемь.
         * todo | Что такое метод - метод, он же в некоторых языках функция, это какое то поведение
         * todo | если класс это описание объекта, допустим машина, то метод это его поведение, то что эта
         * todo | машина может делать, например сигналить.
         * todo | Что такое String в Java? Какой это тип данных?
         * todo | String – это класс в Java, который прописан в пакете java.lang. Это не примитивный тип данных,
         * todo | как int и long. Класс String представляет строковый набор символов.
         * todo | Рефакторинг это улучшение кода, когда вы его написали, код который работает, но скорее всего вы его с первого раза не написали
         * todo | его идеально, нам нужно его обработать, обработка напильников, полировка, шлифовка, шпаклей херовка, цементировка, синонимыСловафрафаф тфу...
         * todo | Одномерный массив это список, многомерный массив это таблица (матрица).
         * todo | Полиморфизм - работа с несколькими типами, но в то же время у каждого типа будет свое уник. поведение.
         * todo | Инкапсуляция - принцип обертывания данных (переменных) и кода в единое целое, создано для безопасности.
         * todo | Пример инкапсуляции может быть геттеры и сеттеры.
         * todo | Инкапсуляция - это сокрытие реализации, то есть мы отправляем какие то параметры на вход в метод, мы
         * todo | не знаем, что внутри происходит, мы просто получаем обратно уже готовую информацию.
         * todo | А что происходит внутри, это не важно! Так обычно вы будете использовать большинство классов, написанные
         * todo | другими разработчиками (классов и библиотек), не особо разбираясь, как они там внутри работает.
         * todo | Просто прочитав, что данная библиотека сжимает на 30 процентов, вы будете подключать к своему
         * todo | проекту и давать ей картинку в виде бинарного потока, а на выходе получать готовый файлик
         * todo | на 30% меньше и Вас не волнует, что там происходит с этой картинкой.
         * todo | Вы должны руководствоваться тем, что Пользователь должен иметь доступ только к открытой
         * todo | информации файла.
         * todo | Абстракции это процесс сокрытия деталей от пользователей, только функционал будет доступен пользователю.
         * todo | Некоторый код требует чтобы его писали в блоке кода трай кетч \ Безопасным считается код, который проверяется на наличие исключений (ошибок).
         * todo | Не безопасным считается код, который не проверяетмя, но может бросить исключения (ошибки).
         * todo | не безопасный код нужно писать Try catch, - попробовать try сделать что либо, если это не получиться
         * todo | catch - перехватить вылетевший экзепшен.
         * todo | Что такое форматированный ввод: Один из вариантов форматированного ввода в джаве
         * todo | Класс MessageFormat и его статический метод format позволяет подставлять аргументы
         * todo | переданные в данный метод. Данный метод формат уже принимает 2 аргумента (строку Pattern и имя str)
         * todo | Pattern = шаблон, это шаблон проектирования или паттер проектирования.
         * todo | Для того, чтобы обратиться к методу другого класса, нужно написать класс точка и название метода.
         * todo | Если этот метод не статический, то нужно создать экземпляр класса "new", если же он статический, то
         * todo | к нему достаточно обратиться через точку.
         * todo | Чем меньше мы создаем экземпляр класса, чем лучше программа наша работает и упортреляет мало памяти.
         * todo | Процедурный стиль - это стиль в одном классе.
         * todo | Для того, чтобы переменная была не изменяемой используется слово final
         * todo | Пакеты по сути это папки, это структура каталогов вашей программы. Обычно принято создавать папки
         * todo | Ваше доменное имя наоборот, com.lisin.cars
         * todo | Если в Idea пакеты слипаются, то можно правой клавишей по пустой области (Рядом с Project)
         * todo | http://joxi.ru/ZrJzpbMC91daxr.jpg или https://pp.userapi.com/c846019/v846019096/6f14f/wavBB8Ao4Xc.jpg
         * todo | Композиция это взаимодействие никак не связанных классов.
         * todo | Сложение строк String называется конкатинацией.
         * todo | Разницы между ArrayList и LinkedList в способе хранения данных и в способе доступа. Array это связанный список на основе массива и он не хранит данных о соседних элементов,
         * todo | а LinkedList это лист, который хранит связи. Благодаря этим связям идет разный способ доступа, разный способ поиска.
         * todo | По какому идет быстрее поиск? по ArrayList или LinkedList? - смотря что и где искать! Смотря сколько данных и где мы ищем. Если мы ищем данные где то в середине, то нам проще искать по
         * todo | линкед листу, потому что есть связи между соседними элементами, если мы ищем с конца, там с левово или с правово, соотвественно ArrayList будет быстрее.
         * todo | В Array листе данные просто хранятся в куче, друг за другом, в линкед листе они связаны, благодаря тому что каждый знает элемент свой соседний, поиск где то в середине будет осуществляться быстрее.
         * todo | Если все под общей знаменатель подвести, то сказать что ArrayList подходит для большинства решения задач.
         * todo | Если требутся тонкие прикрутки, то нам нужно смотреть, куда утекает память, где лучше оптимизировать.
         * todo | Стеки и очереди являются абстрактными структурами данных, они определяются своими интерфейсами, который содержат определенные методы.
         * todo | Что такое стек? В простом понимании это стопка тарелок, если у нас есть десять тарелок на столе.
         * todo | Стек это абстрактная структура данных, которая содержит список элементов и он работает по принципу последний пришел, первый вышел. Грубо говоря, если вы
         * todo | зашли в очередь в магазин и пролезли самым первым. В отличии от массивов, в стеке мы не можем получить доступ к произвольному элементу, доступ только к последнему элементу осуществляется.
         * todo | Чтобы создать нам стек, нам понадобится разработать метод добавления, удаления, вывода в консоль, а так же проверки на пустоту, ну и соответственно добавлять и удалять элементы мы будем с левой стороны стека.
         */
        System.out.println("Определения </end> ");
    }

    public static void noteJava() {
        System.out.println("Заметки <start> ");
        /**
         * todo | с помощью жука (дебагера) кликаем по нужному участку кода (который исполняется), запускаем и шагаем F8 по шагам, смотрим на выполнение кода.
         * todo | Название переменных и методов начинаются с маленькой буквой, в то время как классы начинаются с большой буквы.
         * todo | Везде, где мы делаем константную проверку, используем свитч, это экономит ресурсы. if проверяет все, а вот свитч
         * todo | остановиться на нужном условии и выйдет из блока кода, не станет дальше проверять, в отличии от if.
         * todo | Случайные значения получаются с помощью класса рандом!
         * todo | В джава всЁ объекты, кроме примитивных типов. Примитивные типы не объекты, но у них есть оболочки!
         * todo | В предыдущем прохождении джавы я не раздечал deepToString и toString = deepToString пишется когда 2 мерный массив,
         * todo | а toString пишется, когда одномерный массив!
         * todo | (!isCellAvailable) - "!" знак говорит о том: Пока метод не true - или не false
         * todo | ! по другому этот знак говорит нам о том, что это "не", обозначает отрицание
         * todo | Не равно, не метод, восклицательный знак инвертирует
         * todo | полученное значения. В место тру делает фолс и наоборот.
         * todo | Принято в джаве методы которые возвращают булеан boolean называть с переменной is
         * todo | isCellAvailable - перевод с англ на русский - клеткаДоступна? с вопросительной интонацией
         * todo | Но не все boolean могут быть вопросительными!
         * todo | Проход цикла называются итерациями
         * todo | Объявления переменной типа объекта, знак присваивания, оператор new, и соответственно класс с круглыми скобками.
         * todo | Car lancer = new Car(); // То-есть Car название класса, lancer переменная (это переменная которая содержит ссылку на объект с ссылкой на объект Car), new (оператор который создает объект) - экземпляр класса, Car() название класса.
         * todo | Вот например Player player = new Player();
         * todo | Мы обращаемся к классу Player, создаем переменную player и создаем экземпляр класса Player(), чтобы воспользоваться возможностями класса Player(), которые написали ранее за нас программисты.
         * todo | Данная запись Car logan = new Car(); а именно Car() - Вызов конструктора по умолчанию.
         * todo | Чтобы получить доступ к полям объекта, набираем Класс.имяМетода
         * todo | Что такое reqex - это регулярное выражение.
         * todo | Конвенция по написанию кода java: https://habr.com/post/112042/
         * todo | Очереди напоминают нам стек с одним отличием - в очереди извлекается элемент, который был добавлен первым!
         * todo | Как в реальной жизни - очередь к врачу! Первым вошел, первым вышел! Первый пришел в очередь, первым ушел от врача.
         * todo | Что такое циклический перенос: Как добавляются элементы в очередь?
         * todo | Что такое циклический перенос - (Кольцевой буфер) - записываем в середину буфера цифру 1, то есть первая ячейка будет в центре.
         * todo | Затем предположим, что после 1 будет идти 2 и 3 - выглядит это так: [][][1][2][3][][]
         * todo | Если после этого два элемента должны быть удалены из буфера, то выбираются два наиболее старых
         * todo | элемента. В нашем случае удаляются элементы 1 и 2, в буфере остается только цифра 3 [][][][][3][][]
         * todo | Если в буфере находиться 7 элементов, то он заполнен [6][7][8][9][3][4][5]
         * todo | Если продолжим писать в буфер, не принимая во внимание его заполненность, то новые данные начнут
         * todo | перезаписывать старые данные. В нашем случае если мы запишем букву А и букву Б, то наши
         * todo | 3 и 4 будут перезаписаны. [6][7][8][9][A][B][5]
         * todo | Есть еще один вид очереди - ДЕК: Двухсторонняя очередь
         * todo | Вставка и удаление элементов производиться у нас с обоих концов и соответствующие методы мы можем называть допустим left Insert Right Insert, Left remove right remove - то есть удаление и вставка по бокам!
         * todo | В случае если мы ограниваемся только вставкой слева справа, то у нас ДЕК работает как Стек!
         * todo | Если мы ограничиваемся методами ремув по бокам, то соотвественно у нас ДЕК работает как очередь.
         * todo | Дек очень гибкий, чем стек и очередь! Но использование Дека используется редко, чем стеки и очередь!
         * todo | То есть мы можем по краям элементы добавлять и по краям эти элементы удалять!
         * todo | Что такое приоритетная очередь? Она похожа на обычную с определенным ключем. Элементы извлекаются из начала, а вот попадают в нее в порядке сортировки. То есть данные хранятся там в порядке по ключу!
         * todo | В начале очереди находиться элемент, у которого ключ имеет минимальное значение (самый приоритетный элемент - с меньшим ключом).
         * todo | Могут задать вопрос на собеседовании - Напишите мне пузырьковую сортировку!
         */
        System.out.println("Заметки </end> ");
    }

    public static void StringOp() {
        System.out.println("String <start> ");
        /**
         * todo | все инты автоматом приобразуются к строке - конкатинация.
         * todo | если мы скажем компилятору, что нам нужно с начало выполнить сложение, то он будет складывать инты (5+5)
         * todo | а уже затем наше полученное число 10 приведется к строке.
         * todo | принтлн вызывает как мы помним ту стринг, который находиться в объекте обджект.
         * todo | System.out.println(hello + 5);
         * todo | System.out.println(hello.charAt(3)); // вернет нам символ из нашей строки. Числа идут с нуля.
         * todo | System.out.println("джаба".codePointCount());
         * todo | toString превратить строку в строку
         * todo | codePointAt - вернет нам интовое значение символа находящийся по данному индексу в строке.
         * todo | codePointBefore - вернет значение предыдущего символа.
         * todo | codePointCount - колличество символов между начальным и конечным индексом.
         * todo | compareTo - сравнивает строку с со строкой переданной в качестве параметра.
         * todo | compareToIgnoreCase - делает тоже самое, но игнорирует заглавные и прописные строчные буквы.
         * todo | concat - сложить 2 строки.
         * todo | contains - содержит ли данная строка данный символ, данную последовательность символов.
         * todo | contentEquals - сравнивание на содержание данной последовательности, а так же на совпадение.
         * todo | contentEquals - может принимать буфер
         * todo | endsWith - заканчивается на, то есть то есть можно передать туда допустим часть строки и (ну несколько символов) и он проверит конкретную строку, заканчивается ли она на эти конкретные символы. Можно так хорошо проверять расширение файлов.
         * todo | equals - это сравнить
         * todo | equalsIgnoreCase - это сравнить игнорируя.
         * todo | getBytes - возвращает массив байтов данной строки
         * todo | getBytes - возвращает байты для заданной кодировки
         * todo | getBytes - возвращает байты для заданной кодировки по имени
         * todo | hashCore() - возвращает хеш код данной строки.
         * todo | indexOf - возвращает первый встретившийся индекс данного символа, если символ в строке встречается несколько раз, то он вернет его первое вхождение
         * todo | indexOf - String может вернуть индекс первого вхождения данного куска строки.
         * todo | На самом деле indexOf перестали быть нужны с появлением регулярных выражений.
         * todo | intern - возвращает каноничное представление строкового объекта
         * todo | isEmpty() - хорошая вещь! Она возвращает тру если строка пуста, то есть не надо проверять на нулл, можно спросить isEmpty!
         * todo | lastIndexOf - последнее вхождение данного символа.
         * todo | lastIndexOf - Чаще применяется для поиска и разбиение различных вещей по точкам, если вы знаете что последним разделителем будет косой сфлеш, ищите последнее вхождение него, получаете этот индекс и от этого индекса считываете три или четыре символа, в зависимости от того сколько там есть.
         * todo | length - вернет Вам строку.
         * todo | matches - на вход принимает легулярное выражение.
         * todo | offsetByCodePoint - отступы по кодам и юникодам.
         * todo | regionMatches - ищем совпадение только в каком то отдельном куске данной строке.
         * todo | regionMatches - только принимает уже булеан игнор кейс + еще нужно ли игнорировать большие и маленькие буквы?
         * todo | replace - заменяет символ все символы в данной строке, которые совпадают - то есть полностью меняем состав строки.
         * todo | replaceAll - принимает на вход регулярное выражение и меняет целые куски.
         * todo | replaceFirst - заменяет только первое вхождение данной строки.
         * todo | split - делит данную строку на массив, то есть возвращает массив строк по заданному разделителю.
         * todo | System.out.println(Arrays.toString(hello.split(" "))); // Получаем массив слов, разбили по пробелу.
         * todo | startWith понятно - начинается ли данная строка с символа с заданным отступом.
         * todo | substring - возвращает нам часть строки начиная нам с заданного индекса который передается в параметрах
         * todo | substring - с 2 параметрами, вычленяет строку, начиная с первого индекса и заканчивая вторым по параметрам.
         * todo | toCharArray - превращает строку в массив символов, то есть хеллоу ворлд превратиться в массив символов, в котором будут лежать по 1 символу.
         * todo | toLowerCase - переводит в нижний регистр,
         * todo | toUpperCase - капсит.
         * todo | trim - если строка заканчивается пустыми символами, то он обрежит их. Обрезка строки по пустым символам. Вырезает только пробелы по краям, внутренние символы он нам оставит. Обычно применяется к полям логина и пароля!
         * todo | subSequence - возвращает charSequence по заданным точкам, начальная и конечная индексы символы.
         * todo | Еще это не строка, То есть вернув строки с 0 и 5, вам нужно еще вызвать в него ту стринг, чтобы он напечатался. Вообще он печатается по умолчанию, но вообще всегда когда мы вызываем чарСиквенс, мы должны напечатать его, не забываем!
         */
        System.out.println("String </end> ");
    }
}
